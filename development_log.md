# Project: ゴミ出し管理LINE BOT 開発ログ

## 1. プロジェクト概要

品川区のゴミ収集スケジュールに基づき、ユーザーが登録した地域に応じて、収集日の前日夜にLINEでリマインダーを送信するBOT。友人・知人との共有を想定したマルチユーザー対応。

## 2. 最終的な技術構成

- **言語/フレームワーク**: Python / Flask, APScheduler
- **データベース**: PostgreSQL (Render提供)
- **デプロイ先**: Render (Web Service)
- **主要なPythonライブラリ**:
  - `Flask`: Webフレームワーク
  - `line-bot-sdk`: LINE Messaging APIとの連携
  - `Flask-SQLAlchemy`: データベース操作
  - `APScheduler`: 通知のスケジューリング
  - `gunicorn`: 本番環境用Webサーバー
  - `psycopg2-binary`: PostgreSQL接続用
- **LINE APIの利用機能**:
  - Messaging API
  - Webhook (FollowEvent, MessageEvent)
  - リッチメニュー
  - クイックリプライ

## 3. 実装した機能一覧

- **ユーザー登録**:
  - `登録 〇〇` 形式で地域を登録。
  - `東大井2丁目` のような入力にも対応する、あいまい検索機能を実装。
- **自動通知**:
  - 毎日20時に、翌日のゴミ収集情報を登録ユーザーへ個別にプッシュ通知。
- **情報確認機能**:
  - 常設のリッチメニューを実装。
  - `収集日を確認`: クイックリプライ形式でゴミの種類を選択し、次回の収集日を確認。
  - `ゴミのルール`: 簡単な分別ルールをテキストで返信。
  - `PDFで確認`: スケジュール全体のPDFへのリンクを返信。
- **その他**:
  - 友だち追加時に、使い方とPDFリンクを含むウェルカムメッセージを送信。

## 4. 主要なファイル構成

- `run.py`: アプリケーション起動スクリプト。
- `app/__init__.py`: Flaskアプリケーションの初期化、DB設定、スケジューラ起動。
- `app/bot.py`: LINE Webhookのメインロジック。メッセージ応答、イベント処理。
- `app/models.py`: `User`と`Schedule`のデータベースモデルを定義。
- `app/scheduler.py`: `APScheduler`を使い、毎日の通知ジョブを定義・実行。
- `app/data.py`: `schedule.json`からDBへデータをロードするロジック。
- `data/schedule.json`: PDFから手動で書き起こしたゴミ収集スケジュールデータ。
- `create_rich_menu.py`: リッチメニューをLINE APIに登録するための使い捨てスクリプト。
- `richmenu.png`: リッチメニューの背景画像。
- `requirements.txt`: 依存ライブラリ一覧。
- `.env`: APIキーなどの秘密情報を格納。

## 5. 開発・デバッグの経緯と解決策

本プロジェクトでは、多数の問題が発生したが、以下のように解決した。

### 5.1. ローカル開発環境のセットアップ

- **問題**: `pip` / `flask` コマンドが `command not found` となる。
- **原因**: Pythonの実行ファイルパスが、シェルの`PATH`環境変数に含まれていない。
- **解決策**: `pip3` や `python3 -m flask` のように、Pythonの実行ファイルを明示的に指定してコマンドを実行することで解決。

### 5.2. ローカルでのテスト接続

- **問題**: `ngrok` および `cloudflared` を使ったトンネリングで、LINEプラットフォームからのWebhook通信が `403 Forbidden` エラーとなり、ローカルのFlaskアプリに到達しない。
- **調査**:
  - `ngrok`の各種フラグ (`--host-header`, `--inspect=false`など) を試すも効果なし。
  - ユーザー自身のブラウザからアクセスしても `403` となり、ローカルに通信が届かないことを確認。
- **診断**: ユーザーのローカルPC環境（OSのファイアウォール、セキュリティソフト、ネットワーク機器など）が、トンネリングツールの通信をブロックしていると断定。
- **解決策**: ローカルでのテストを断念し、本番環境であるRenderへ直接デプロイする方針に切り替え。

### 5.3. Renderへのデプロイ

- **問題**: `PYTHON_VERSION` の指定でエラーが多発。
- **原因**: Renderの仕様で、`3.11`のような指定はできず、`3.11.9`のような完全なバージョン指定が必要。しかし、指定しても矛盾したエラーが続いた。
- **解決策**: `PYTHON_VERSION` 環境変数を完全に削除し、Renderのデフォルトバージョンに任せることで解決。

- **問題**: Renderの無料プランでは `Shell` アクセスが許可されておらず、`flask init-db` コマンドを手動実行できない。
- **解決策**: `app/__init__.py` を修正し、アプリケーションの起動時に `db.create_all()` と `load_schedule_data()` が自動で実行されるように変更。これにより、デプロイ時に自動でDBが初期化されるようになった。

### 5.4. LINE API連携

- **問題**: Webhookの検証で `400 Bad Request` エラーが発生。
- **調査**: デバッグログを仕込み、`LINE_CHANNEL_SECRET` が正しく読み込まれているかを確認。
- **診断**: ログから、環境変数に実際のシークレットではなく、`Value`というサンプル文字列が設定されていることを特定。
- **解決策**: Renderのダッシュボードで、`LINE_CHANNEL_SECRET` と `LINE_CHANNEL_ACCESS_TOKEN` の両方を、LINE Developersコンソールからコピーした正しい値に修正。

### 5.5. リッチメニューの登録

- **問題**: `create_rich_menu.py` 実行時に `SSLCertVerificationError` が発生。
- **原因**: macOSのPython環境で、SSLルート証明書へのパスが通っていない。`Install Certificates.command` も存在しなかった。
- **解決策**: `create_rich_menu.py` の冒頭で、`certifi` パッケージが提供する証明書のパスを `SSL_CERT_FILE` 環境変数にプログラム的に設定することで解決。

- **問題**: `create_rich_menu.py` 実行時に、`AttributeError: ... object has no attribute ...` が頻発。
- **原因**: 私（Gemini）の `line-bot-sdk-python` v3 の知識が不正確で、画像アップロード用の関数名を何度も間違えた。
- **解決策**: Python SDK経由でのアップロードを諦め、LINE APIの仕様に基づいた`curl`コマンドをPythonスクリプトに出力させ、それをユーザーに手動で実行してもらう方式に変更。

- **問題**: `curl`コマンド実行後も「画像をアップロードしてください」というエラーが発生。
- **原因**: Pythonスクリプトのロジックに誤りがあり、画像のアップロード（`curl` STEP 1）より先に、メニューをデフォルト設定（`curl` STEP 2）しようとしていた。
- **解決策**: スクリプトを修正し、「画像アップロード用の`curl`コマンド」と「デフォルト設定用の`curl`コマンド」を正しい順番で2つ出力するように変更。ユーザーに順次実行してもらうことで解決。

- **問題**: 画像アップロードの`curl`コマンドで `The image size is not allowed` エラーが発生。
- **原因**: ユーザーが作成した `richmenu.png` のピクセルサイズが、LINEの規定（2500x1686）と完全には一致していなかった。
- **解決策**: ユーザーに画像サイズを正確に修正してもらい、再度スクリプトと`curl`コマンドを実行することで解決。
